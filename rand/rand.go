// Copyright 2014, Joe Tsai. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE.md file.

// Package rand implements a pseudo-random number generator (PRNG).
//
// This was designed to be a faster alternative to the built-in /dev/urandom
// device built into most Linux kernels. This PRNG is based on the
// Advanced Encryption Standard (AES) cipher operating in cipher-block chaining
// (CBC) mode. Some initial data is continually encrypted over and over and
// should provide pseudo-random data of cryptographic quality.
//
// This implementation can generate data significantly faster than /dev/urandom
// by running generator routines in parallel. By default, this library only
// operates using one routine, but the number of routines can be set using the
// SetNumRoutines function. The reference command-line implementation sets the
// number of routines to be equal to the number of cores available.
//
// High-end processors are starting to support the AES-NI instruction set that
// can vastly improve AES encoding rates. The underlying Go library does take
// advantage of these instructions if available. In that situation, this library
// is likely to be more memory-throughput bound than CPU bound. Other than each
// generator occupying about 1MB of memory, this should not lead to noticeable
// degradation of performance since generators will block if their outputs are
// not consumed fast enough.
//
// The author does not take responsibility for any damages potentially caused if
// the data generated by this library is not actually cryptographically-secure.
package rand

import "io"
import "sync"
import "crypto/aes"
import "crypto/rand"
import "crypto/cipher"

var reader = newCrypter()
var Reader io.Reader = reader

type crypter struct {
	dataChan chan []byte
	monChan  chan mondata
	buffer   []byte
	lock     sync.Mutex
}

type mondata struct {
	num int
	ret chan int
}

func newCrypter() *crypter {
	// TODO(jtsai): By default, this library will only spin up one generator
	// routine at startup. This is to avoid unnecessary crunching of copious
	// amounts of pseudo-random data if the application doesn't actually use
	// them. In the future, the library should start with one routine and
	// automatically ramp up to meet demands. This algorithm should take into
	// account that AES-NI instructions on x86 will vastly speed up AES.
	crypt := new(crypter)
	crypt.dataChan = make(chan []byte, 1)
	crypt.monChan = make(chan mondata, 1)
	crypt.monChan <- mondata{1, nil}

	go crypt.monitor()
	return crypt
}

func (c *crypter) Read(buf []byte) (n int, err error) {
	c.lock.Lock()
	defer c.lock.Unlock()

	if len(c.buffer) == 0 {
		c.buffer = <-c.dataChan
	}
	n = copy(buf, c.buffer)
	c.buffer = c.buffer[n:]

	return n, nil
}

// Monitor routine that starts and stops generator routines to match the number
// of routines specified by the SetNumRoutines function.
func (c *crypter) monitor() {
	var genQuits []chan bool
	var md mondata
	for ok := true; ok; {
		select {
		case md, ok = <-c.monChan:
			numPre := len(genQuits)

			if md.num > 0 {
				// Start routines
				for len(genQuits) < md.num {
					quit := make(chan bool)
					genQuits = append(genQuits, quit)
					go c.generator(quit)
				}

				// End routines
				for _, quit := range genQuits[md.num:] {
					close(quit)
				}
				genQuits = genQuits[:md.num]
			}

			if md.ret != nil {
				md.ret <- numPre
			}
		}
	}
}

// Generator routine that generates pseudo-random data by continuously
// encrypting data using the AES cipher running in CBC mode. To avoid producing
// a ton of data initially that may not get used, the generator starts with
// generating 4KiB and gradually works up to 1MiB.
func (c *crypter) generator(quit chan bool) {
	const minBlocks = 256
	const maxBlocks = 65536

	// Create a new encryption cipher with random key
	key := make([]byte, aes.BlockSize)
	if _, err := rand.Read(key); err != nil {
		panic("Could not seed a random cryptographic key.")
	}
	aesCipher, _ := aes.NewCipher(key)

	// Create a new CBC generator with a random initialization vector
	vector := make([]byte, aes.BlockSize)
	if _, err := rand.Read(vector); err != nil {
		panic("Could not seed a random initialization vector.")
	}
	cbcCipher := cipher.NewCBCEncrypter(aesCipher, vector)

	numBlocks := minBlocks
	data := make([]byte, aes.BlockSize*numBlocks)
	for live := true; live; {
		// Generate pseudo-random data by encrypting in CBC mode
		cbcCipher.CryptBlocks(data, data)

		// Grow the blocksize to be more efficient
		dataCopy := data
		if numBlocks < maxBlocks {
			data = append(data, make([]byte, aes.BlockSize*numBlocks)...)
			numBlocks *= 2
		} else {
			dataCopy = append([]byte(nil), data...)
		}

		select {
		case c.dataChan <- dataCopy:
			continue
		case live = <-quit:
			break
		}
	}
}

// Read is a helper function that calls Reader.Read using io.ReadFull.
// On return, n == len(b) if and only if err == nil.
func Read(buf []byte) (n int, err error) {
	return io.ReadFull(Reader, buf)
}

// Sets the number of routines that will generate pseudo-random data and returns
// the previous setting. If n < 1, it does not change the current setting.
// By default, the number of routines starts off at 1.
func SetNumRoutines(num int) int {
	ret := make(chan int)
	reader.monChan <- mondata{num, ret}
	return <-ret
}
